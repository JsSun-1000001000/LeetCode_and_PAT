## 分析

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。
每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：
- `0 <= j <= nums[i]` 且
- `i + j < n`
返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

23114

如果某一个点可以跳跃距离为3，那么后面三个都可以作为起跳点；
跳跃次数之和跳跃操作有关，和从哪个跳跃点开始跳无关；

end 就是你在上一次更新end的时候那个点能跳到的最远距离，要想走更远，得在跳一次了（step ++）

## 代码

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans = 0;//结果 最小跳跃次数
        int start = 0;
        int end = 1;s
        //不超过数组的大小就可以跳
        while(end < nums.size()){
            int maxPos = 0;
            //循环找能跳跃的最远距离
            for(int i = start; i < end; i++){
                maxPos = max(maxPos, i+nums[i]);
            }
            //设定下一次起跳点范围开始的位置
            start = end;
            //下一次起跳点范围结束的位置
            end = maxPos + 1;
            //跳跃次数
            ans++;
        }
        return ans;
    }
};
```