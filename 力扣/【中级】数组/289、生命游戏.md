## 分析

## 代码
```cpp
class Solution {
public:
    // 生命游戏核心函数，board是传入的棋盘（二维数组），&表示引用传递，直接修改原数组
    void gameOfLife(vector<vector<int>>& board) {
// 1. 复制原始棋盘到copy中，因为更新状态时需要基于原始状态判断，不能边改边判断
        vector<vector<int>> copy = board;
        
        // 2. 获取棋盘的行数x和列数y
        int x = board.size();       // 行数（垂直方向）
        int y = board[0].size();    // 列数（水平方向）
        
        // 3. 遍历棋盘上的每一个细胞
        for(int i = 0;i < x;i++){ // 遍历每一行（i是行索引）
            for(int j = 0;j < y;j++){// 遍历每一列（j是列索引）
                int count=0;// 初始化当前细胞的存活邻居数量
    // 4. 统计当前细胞周围8个方向的存活邻居数量（1表示存活，0表示死亡）
                if(j>0&&copy[i][j-1]) count+=1; 
                // 左：j>0确保不越界，copy[i][j-1]为1则计数+1
                if(j<y-1&&copy[i][j+1]) count+=1;
                // 右：j<y-1确保不越界
                if(i>0&&copy[i-1][j]) count+=1;
                // 上：i>0确保不越界
                if(i<x-1&&copy[i+1][j]) count+=1;
                // 下：i<x-1确保不越界
                if(i>0&&j>0&&copy[i-1][j-1]) count+=1;
                // 左上：i和j都大于0
                if(i>0&&j<y-1&&copy[i-1][j+1]) count+=1;
                 // 右上：i>0且j<y-1
                if(i<x-1&&j>0&&copy[i+1][j-1]) count+=1;
                // 左下：i<x-1且j>0
                if(i<x-1&&j<y-1&&copy[i+1][j+1]) count+=1;
                // 右下：i和j都不越界
// 5. 根据生命游戏规则更新当前细胞的状态（直接修改原board）
                if(count<2) board[i][j]=0;      
                // 规则1：存活邻居<2，细胞死亡
                else if(count==3) board[i][j]=1;
                // 规则2：存活邻居=3，细胞存活（无论原本状态）
                else if(count>3) board[i][j]=0; 
                // 规则3：存活邻居>3，细胞死亡
// 注意：count==2时，细胞保持原状态（无需修改，因为board初始就是原状态）
            }
        }
    }
};
```
## 代码 

我觉得可以用五子棋里表示方向的方式
```cpp

```