## 分析

## 代码
```cpp
class Solution {
public:
    // 生命游戏核心函数，board是传入的棋盘（二维数组），&表示引用传递，直接修改原数组
    void gameOfLife(vector<vector<int>>& board) {
// 1. 复制原始棋盘到copy中，因为更新状态时需要基于原始状态判断，不能边改边判断
        vector<vector<int>> copy = board;
        
        // 2. 获取棋盘的行数x和列数y
        int x = board.size();       // 行数（垂直方向）
        int y = board[0].size();    // 列数（水平方向）
        
        // 3. 遍历棋盘上的每一个细胞
        for(int i = 0;i < x;i++){ // 遍历每一行（i是行索引）
            for(int j = 0;j < y;j++){// 遍历每一列（j是列索引）
                int count=0;// 初始化当前细胞的存活邻居数量
    // 4. 统计当前细胞周围8个方向的存活邻居数量（1表示存活，0表示死亡）
                if(j>0&&copy[i][j-1]) count+=1; 
                // 左：j>0确保不越界，copy[i][j-1]为1则计数+1
                if(j<y-1&&copy[i][j+1]) count+=1;
                // 右：j<y-1确保不越界
                if(i>0&&copy[i-1][j]) count+=1;
                // 上：i>0确保不越界
                if(i<x-1&&copy[i+1][j]) count+=1;
                // 下：i<x-1确保不越界
                if(i>0&&j>0&&copy[i-1][j-1]) count+=1;
                // 左上：i和j都大于0
                if(i>0&&j<y-1&&copy[i-1][j+1]) count+=1;
                 // 右上：i>0且j<y-1
                if(i<x-1&&j>0&&copy[i+1][j-1]) count+=1;
                // 左下：i<x-1且j>0
                if(i<x-1&&j<y-1&&copy[i+1][j+1]) count+=1;
                // 右下：i和j都不越界
// 5. 根据生命游戏规则更新当前细胞的状态（直接修改原board）
                if(count<2) board[i][j]=0;      
                // 规则1：存活邻居<2，细胞死亡
                else if(count==3) board[i][j]=1;
                // 规则2：存活邻居=3，细胞存活（无论原本状态）
                else if(count>3) board[i][j]=0; 
                // 规则3：存活邻居>3，细胞死亡
// 注意：count==2时，细胞保持原状态（无需修改，因为board初始就是原状态）
            }
        }
    }
};
```
## 代码 

我觉得可以用五子棋里表示方向的方式

另外，这个大哥有点牛，他用位运算复用存储空间，节省了copy的存储空间
``` cpp
class Solution {
public:
    // 生命游戏核心函数，board为引用传递的棋盘，原地修改
    void gameOfLife(vector<vector<int>>& board) {
        // 定义8个方向的行偏移量（dx）和列偏移量（dy），对应8个邻居方向：
        // dx[-1,0,1,-1,1,-1,0,1] 对应 上、中、下 三个行方向
        // dy[-1,-1,-1,0,0,1,1,1] 对应 左、中、右 三个列方向
        // 组合后依次是：左上、上、右上、左、右、左下、下、右下
        int dx[] = {-1,0,1,-1,1,-1,0,1};
        int dy[] = {-1,-1,-1,0,0,1,1,1};

        // 第一层循环：遍历棋盘的每一行（i为行索引）
        for(int i=0;i<board.size();i++){
            // 第二层循环：遍历当前行的每一列（j为列索引）
            for(int j=0;j<board[0].size();j++){
                int count = 0; // 初始化当前细胞的存活邻居数量
                
                // 第三层循环：遍历8个方向，统计存活邻居
                for(int k=0;k<8;k++){
                    int nx=i+dx[k]; // 计算邻居的行索引（当前行+方向偏移）
                    int ny=j+dy[k]; // 计算邻居的列索引（当前列+方向偏移）
                    
                    // 边界检查：确保邻居索引在棋盘范围内（不越界）
                    if(nx>=0&&nx<board.size()&&ny>=0&&ny<board[0].size()){
                        // 关键：board[nx][ny]&1 只取当前状态的最低位（0/1）
                        // 因为后续会把下一状态存在第二位，这里只统计原始存活状态
                        count+=(board[nx][ny]&1);
                    }
                }

                // 核心逻辑：根据规则更新“下一状态”（存到第二位）
                if(board[i][j]==1){ // 如果当前细胞是存活状态（最低位为1）
                    // 规则：存活细胞有2/3个存活邻居，下一状态仍存活
                    if(count==2||count==3){
                        // 位运算：board[i][j] |= 2 等价于 board[i][j] = board[i][j] | 2
                        // 2的二进制是10，这一步把第二位设为1（表示下一状态存活），最低位保持不变
                        board[i][j]|=2;
                    }
                    // 其他情况（count<2或count>3）：第二位保持0（下一状态死亡），无需操作
                }
                else{ // 如果当前细胞是死亡状态（最低位为0）
                    // 规则：死亡细胞有3个存活邻居，下一状态复活
                    if(count==3){
                        // 同样把第二位设为1（下一状态存活）
                        board[i][j]|=2;
                    }
                }
            }
        }

        // 最终状态更新：把所有细胞的第二位（下一状态）右移到最低位
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                // 右移1位：board[i][j] >>= 1 等价于 除以2取整
                // 例如：原数是3（二进制11）→ 右移后1（存活）；原数是2（二进制10）→ 右移后1；原数是1（二进制01）→ 右移后0
                board[i][j]>>=1;
            }
        }
    }
};
```

看着有点别扭：
```cpp
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int dx[] = {-1,0,1,-1,1,-1,0,1};
        int dy[] = {-1,-1,-1,0,0,1,1,1};
  
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                int count = 0;
                for(int k=0;k<8;k++){
                    int nx=i+dx[k];
                    int ny=j+dy[k];
                    if(nx>=0&&nx<board.size()&&ny>=0&&ny<board[0].size()){
                        count+=(board[nx][ny]&1);
                    }
                }
                if(board[i][j]==1){
                    if(count==2||count==3){
                        board[i][j]|=2;
                    }
                }
                else{
                    if(count==3){
                        board[i][j]|=2;
                    }
                }
            }
        }
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                board[i][j]>>=1;
            }
        }
    }
};
```