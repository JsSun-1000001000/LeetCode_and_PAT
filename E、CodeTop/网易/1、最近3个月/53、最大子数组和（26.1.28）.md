## [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

## 分析

第一种思路是前缀和
第二种思路是动态规划

## 代码

使用前缀和的思路：

```cpp
#include <climits>
#include <algorithm>
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;  //结果
        int Min = 0;        //存储前缀和最小值
        int sum = 0;        //存储当前前缀和
        for( int i : nums){
            sum += i;       //更新前缀和
            ans = max(ans, sum - Min);  //计算当前子数组和，更新最大值
            Min = min(Min, sum);    //更新前缀和的最小值
        }
        return ans;
    }
};
```

使用动态规划的思路：

**我几把真不会这个啊，我先学学。。。**

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> f(nums.size());
        f[0] = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            f[i] = max(f[i - 1], 0) + nums[i];
        }
        //C++20 引入的一个算法，用于返回给定范围内的最大值。
        //它有三种重载形式，
        //分别用于比较两个值、初始化列表中的值以及范围内的值。
        return ranges::max(f);
    }
};
```
