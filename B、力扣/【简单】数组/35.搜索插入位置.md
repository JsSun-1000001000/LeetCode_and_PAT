## 分析

根据target的值，找有序数组中他的位置，没有的话，返回他应该在的位置

有一个要求：时间复杂度$O(log_n)$ 还是查找，就用二分查找

找到大于等于target的选项
## 代码
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n - 1, location = n;
        while(left <= right){
            int mid = ((right - left)/2)+left;
            if(target <= nums[mid]){
                location = mid;
                right = mid - 1;
            }
            else{
                left = mid + 1;
            }
        }
        return location;
    }
};
```
## 优化
有一个点，可以优化，就是用`>>`代替除法，会快一点点